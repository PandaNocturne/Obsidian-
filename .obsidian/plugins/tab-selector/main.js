/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TabSelector
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/util.ts
var STYLES_ID = "tab-selector-styles";
var deleteStyles = () => {
  const styleElm = document.getElementById(STYLES_ID);
  if (styleElm) {
    document.getElementsByTagName("HEAD")[0].removeChild(styleElm);
  }
};
var createStyles = (styles) => {
  const styleSheet = document.createElement("style");
  setAttributes(styleSheet, { type: "text/css", id: STYLES_ID });
  const header = document.getElementsByTagName("HEAD")[0];
  header.appendChild(styleSheet);
  styles.forEach(({ selector, property, value }) => {
    addNewStyle(selector, `${property}: ${value}`, styleSheet);
  });
};
var setAttributes = (element, attributes) => {
  for (const key in attributes) {
    element.setAttribute(key, attributes[key]);
  }
};
var addNewStyle = (selector, style, sheet) => {
  sheet.textContent += selector + `{${style}}`;
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  showAliases: false,
  replaceToAliases: false,
  showPaths: false,
  showPaginationButtons: true,
  showLegends: true,
  focusColor: "#00b4e0",
  characters: "asdfghjkl;"
};
var CHAR_LENGTH = {
  min: 4,
  max: 10
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2").setText("Tab Selector - Settings");
    new import_obsidian.Setting(containerEl).setName(`Show aliases`).setDesc(`When enabled, show file's aliases on button.`).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showAliases).onChange(async (value) => {
        this.plugin.settings.showAliases = value;
        this.plugin.settings.replaceToAliases = false;
        await this.plugin.saveData(this.plugin.settings);
        this.updateStyleSheet();
        this.display();
      })
    );
    new import_obsidian.Setting(containerEl).setName(`Replace the filename to aliases`).setDesc(`When enabled, if aliases is set the file, replace the filename to aliases.`).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.replaceToAliases).onChange(async (value) => {
        this.plugin.settings.replaceToAliases = value;
        await this.plugin.saveData(this.plugin.settings);
        this.updateStyleSheet();
      })
    ).setDisabled(!this.plugin.settings.showAliases);
    new import_obsidian.Setting(containerEl).setName(`Show paths`).setDesc(`When enabled, show file's paths on button.`).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showPaths).onChange(async (value) => {
        this.plugin.settings.showPaths = value;
        await this.plugin.saveData(this.plugin.settings);
        this.updateStyleSheet();
      })
    );
    new import_obsidian.Setting(containerEl).setName(`Show pagination buttons`).setDesc("When enabled, show pagination buttons on modal.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showPaginationButtons).onChange(async (value) => {
        this.plugin.settings.showPaginationButtons = value;
        await this.plugin.saveData(this.plugin.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName(`Show legends`).setDesc("When enabled, show legends on modal.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showLegends).onChange(async (value) => {
        this.plugin.settings.showLegends = value;
        await this.plugin.saveData(this.plugin.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Color of button frame on focus").setDesc("Choice your favorite color.").addColorPicker(
      (colorPicker) => colorPicker.setValue(this.plugin.settings.focusColor).onChange(async (value) => {
        this.plugin.settings.focusColor = value;
        await this.plugin.saveData(this.plugin.settings);
        this.updateStyleSheet();
      })
    ).then((settingEl) => this.addResetButton(settingEl, "focusColor"));
    new import_obsidian.Setting(containerEl).setName("Characters used for button hints").setDesc(`Enter ${CHAR_LENGTH.min}~${CHAR_LENGTH.max} non-duplicate alphanumeric characters or symbols.`).addText((text) => {
      let orgCharacters = this.plugin.settings.characters;
      const textComponent = text.setPlaceholder("Enter characters").setValue(this.plugin.settings.characters).onChange(async (value) => {
        const { inputEl } = textComponent;
        if (!this.isDuplicateChars([...value]) && inputEl.validity.valid) {
          inputEl.removeClass("ts-setting-is-invalid");
          this.plugin.settings.characters = value;
          orgCharacters = value;
          await this.plugin.saveSettings();
        } else {
          inputEl.addClass("ts-setting-is-invalid");
        }
        this.updateStyleSheet();
      });
      textComponent.inputEl.addEventListener("blur", () => {
        if (this.isDuplicateChars([...textComponent.inputEl.value]) || !textComponent.inputEl.validity.valid) {
          this.plugin.settings.characters = orgCharacters;
        }
      });
      textComponent.inputEl.setAttrs({
        maxLength: CHAR_LENGTH.max,
        required: true,
        pattern: `[!-~]{${CHAR_LENGTH.min},${CHAR_LENGTH.max}}`
      });
      return textComponent;
    }).then((settingEl) => this.addResetButton(settingEl, "characters"));
  }
  updateStyleSheet(isTeardown = false) {
    deleteStyles();
    if (isTeardown) {
      return;
    }
    const { showAliases, replaceToAliases, showPaths, focusColor, characters } = this.plugin.settings;
    const aliasesHeight = showAliases && !replaceToAliases ? showPaths ? 14 : 10 : 0;
    const pathHeight = showPaths ? 10 : 0;
    const buttonHeight = 32 + aliasesHeight + pathHeight;
    createStyles([
      // 8 is margin of between buttons.
      { selector: ".ts-buttons-view", property: "min-height", value: `${buttonHeight * characters.length + 8 * (characters.length - 1)}px` },
      { selector: ".ts-leaf-name-btn:focus", property: "outline", value: `2px solid ${focusColor}` }
    ]);
  }
  isDuplicateChars(chars) {
    return chars.some((char, idx) => chars.slice(idx + 1).includes(char));
  }
  addResetButton(settingEl, settingKey, refreshView = true) {
    settingEl.addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
      const settingValue = DEFAULT_SETTINGS[settingKey];
      this.plugin.settings[settingKey] = settingValue;
      await this.plugin.saveSettings();
      this.updateStyleSheet();
      if (refreshView) {
        this.display();
      }
    }));
  }
};

// src/modal.ts
var import_obsidian2 = require("obsidian");
var UP_KEY = "ArrowUp";
var DOWN_KEY = "ArrowDown";
var LEFT_KEY = "ArrowLeft";
var RIGHT_KEY = "ArrowRight";
var FOOTER_ITEMS = [
  { keys: "\u2191 / \u2193", description: "Move focus" },
  { keys: "\u2190 / \u2192", description: "Switch pages" },
  { keys: "Enter / Space", description: "Switch to focused tab" },
  { keys: "", description: "Quick switch tab" }
];
var TabSelectorModal = class extends import_obsidian2.Modal {
  constructor(app, settings, leaves) {
    super(app);
    this.leaves = [];
    this.chars = [];
    this.buttonMap = /* @__PURE__ */ new Map();
    this.focusPosition = 0;
    this.pagePosition = 0;
    this.settings = settings;
    this.leaves = leaves;
    this.chars = [...this.settings.characters];
  }
  get currentLeaves() {
    return this.leaves.slice(0 + this.pagePosition * this.chars.length, this.chars.length + this.pagePosition * this.chars.length);
  }
  onOpen() {
    this.modalEl.addClasses(["tab-selector-modal", "ts-modal"]);
    this.generateHeader(this.contentEl);
    this.buttonsViewEl = this.contentEl.createDiv("ts-buttons-view");
    this.generateButtons(this.buttonsViewEl, this.currentLeaves);
    this.generateFooter(this.contentEl);
    this.eventListenerFunc = this.handlingKeyupEvent.bind(this);
    window.addEventListener("keyup", this.eventListenerFunc);
  }
  onClose() {
    window.removeEventListener("keyup", this.eventListenerFunc);
    this.contentEl.empty();
  }
  generateHeader(contentEl) {
    contentEl.createDiv("ts-header", (el) => {
      this.pageCounterEl = el.createSpan("");
      this.updatePageCount();
      el.createSpan("").setText("/");
      el.createSpan("").setText(`${Math.ceil(this.leaves.length / this.chars.length)}`);
    });
  }
  generateButtons(contentEl, leaves) {
    var _a;
    this.focusPosition = 0;
    this.buttonsViewEl.empty();
    leaves.forEach((leaf, idx) => {
      contentEl.createDiv("ts-leaf-row", (el) => {
        const shortcutBtnEl = el.createEl("button", { text: this.chars.at(idx) });
        shortcutBtnEl.setAttr("tabIndex", -1);
        shortcutBtnEl.addClass("ts-shortcut-btn");
        shortcutBtnEl.addEventListener("click", () => this.clickLeafButton(leaf));
        const itemBtnEl = el.createEl("button");
        itemBtnEl.addClass("ts-leaf-name-btn");
        itemBtnEl.addEventListener("click", () => this.clickLeafButton(leaf));
        const itemNameEl = itemBtnEl.createSpan("ts-leaf-name");
        itemNameEl.setText(leaf.getDisplayText());
        this.reflectOptions(leaf, el, itemBtnEl, itemNameEl);
        this.buttonMap.set(leaf.id || "", itemBtnEl);
      });
    });
    this.buttonMap.get(((_a = this.currentLeaves.at(0)) == null ? void 0 : _a.id) || "").focus();
    this.updatePageCount();
  }
  reflectOptions(leaf, el, itemBtnEl, itemNameEl) {
    var _a, _b;
    if (this.settings.showAliases && !this.settings.replaceToAliases || this.settings.showPaths) {
      el.addClass("ts-leaf-row-added-options");
    }
    if (this.settings.showAliases) {
      const props = ((_b = (_a = leaf.view) == null ? void 0 : _a.metadataEditor) == null ? void 0 : _b.properties) || [];
      const aliases = props.filter((prop) => prop.key === "aliases").flatMap((prop) => prop.value).filter((value) => value != null);
      if (this.settings.replaceToAliases) {
        this.replaceLeafName(aliases, itemBtnEl, itemNameEl);
      } else {
        this.addAliasesEl(aliases, itemBtnEl);
      }
    }
    if (this.settings.showPaths) {
      this.addPathEl(leaf, itemBtnEl);
    }
  }
  replaceLeafName(aliases, itemBtnEl, itemNameEl) {
    if (aliases.length) {
      itemNameEl.detach();
      const wrapperEl = itemBtnEl.createDiv("ts-option-wrapper");
      (0, import_obsidian2.setIcon)(wrapperEl, "corner-up-right");
      wrapperEl.createSpan("ts-leaf-alias").setText(aliases.join(" | "));
    }
  }
  addAliasesEl(aliases, itemBtnEl) {
    const wrapperEl = itemBtnEl.createDiv("ts-option-wrapper");
    (0, import_obsidian2.setIcon)(wrapperEl, "corner-up-right");
    wrapperEl.createEl("small").setText(aliases.join(" | "));
  }
  addPathEl(leaf, itemBtnEl) {
    const wrapperEl = itemBtnEl.createDiv("ts-option-wrapper");
    (0, import_obsidian2.setIcon)(wrapperEl, "folder-closed");
    const { file } = leaf.getViewState().state;
    const fullPath = typeof file === "string" ? file.split(leaf.getDisplayText())[0] || "/" : "-";
    const splitPaths = fullPath.split("/").map((path) => path.length > 20 ? `${path.slice(0, 20)}...` : path);
    const displayPath = splitPaths.length > 3 ? `.../${splitPaths.at(-3)}/${splitPaths.at(-2)}/` : splitPaths.join("/");
    wrapperEl.createEl("small").setText(displayPath);
  }
  generateFooter(contentEl) {
    contentEl.createDiv("ts-footer", (el) => {
      if (this.settings.showPaginationButtons && this.leaves.length > this.chars.length) {
        el.createDiv("ts-page-nav", (navEl) => {
          const prevBtnEl = navEl.createEl("button", { text: "\u2190" });
          prevBtnEl.setAttr("tabIndex", -1);
          prevBtnEl.addClass("ts-nav-btn");
          prevBtnEl.addEventListener("click", () => this.keyupArrowKeys(LEFT_KEY));
          const nextBtnEl = navEl.createEl("button", { text: "\u2192" });
          nextBtnEl.setAttr("tabIndex", -1);
          nextBtnEl.addClass("ts-nav-btn");
          nextBtnEl.addEventListener("click", () => this.keyupArrowKeys(RIGHT_KEY));
        });
      }
      if (this.settings.showLegends) {
        FOOTER_ITEMS.forEach((item) => {
          el.createDiv("ts-legends", (el2) => {
            el2.createSpan("ts-keys").setText(item.keys || `${this.chars.slice(0, 2).join(" / ")} / ... / ${this.chars.slice(-2).join(" / ")}`);
            el2.createSpan("ts-description").setText(item.description);
          });
        });
      }
    });
  }
  updatePageCount() {
    this.pageCounterEl.setText(`${this.pagePosition + 1}`);
  }
  clickLeafButton(leaf) {
    this.close();
    this.app.workspace.setActiveLeaf(leaf);
    const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (view) {
      view.editor.focus();
    }
  }
  handlingKeyupEvent(ev) {
    if (this.chars.includes(ev.key)) {
      this.keyupShortcutKeys(ev.key);
      ev.preventDefault();
      return;
    }
    if ([UP_KEY, DOWN_KEY, LEFT_KEY, RIGHT_KEY].includes(ev.key)) {
      this.keyupArrowKeys(ev.key);
      ev.preventDefault();
      return;
    }
  }
  keyupShortcutKeys(key) {
    var _a, _b;
    const idx = this.chars.indexOf(key);
    (_b = this.buttonMap.get(((_a = this.currentLeaves.at(idx)) == null ? void 0 : _a.id) || "")) == null ? void 0 : _b.click();
  }
  keyupArrowKeys(key) {
    var _a, _b;
    switch (key) {
      case UP_KEY:
        if (this.focusPosition === 0) {
          this.buttonMap.get(((_a = this.currentLeaves.at(-1)) == null ? void 0 : _a.id) || "").focus();
          this.focusPosition = this.currentLeaves.length - 1;
        } else {
          this.buttonMap.get(this.currentLeaves[this.focusPosition - 1].id || "").focus();
          this.focusPosition -= 1;
        }
        break;
      case DOWN_KEY:
        if (this.focusPosition === this.currentLeaves.length - 1) {
          this.buttonMap.get(((_b = this.currentLeaves.at(0)) == null ? void 0 : _b.id) || "").focus();
          this.focusPosition = 0;
        } else {
          this.buttonMap.get(this.currentLeaves[this.focusPosition + 1].id || "").focus();
          this.focusPosition += 1;
        }
        break;
      case LEFT_KEY: {
        const pageSize = this.leaves.length / this.chars.length;
        if (Math.ceil(pageSize) === 1) {
          break;
        }
        if (this.pagePosition === 0) {
          this.pagePosition = this.leaves.length % this.chars.length === 0 ? Math.floor(pageSize) - 1 : Math.floor(pageSize);
        } else {
          this.pagePosition -= 1;
        }
        this.generateButtons(this.buttonsViewEl, this.currentLeaves);
        break;
      }
      case RIGHT_KEY: {
        const pageSize = this.leaves.length / this.chars.length;
        if (Math.ceil(pageSize) === 1) {
          break;
        }
        const lastPage = this.leaves.length % this.chars.length === 0 ? pageSize - 1 : Math.floor(pageSize);
        if (this.pagePosition === lastPage) {
          this.pagePosition = 0;
        } else {
          this.pagePosition += 1;
        }
        this.generateButtons(this.buttonsViewEl, this.currentLeaves);
        break;
      }
      default:
        break;
    }
  }
};

// src/main.ts
var TabSelector = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("file-check-2", "Open tab selector", () => this.openTabSelectorModal());
    this.addCommand({
      id: "open-tab-selector",
      name: "Open tab selector",
      callback: () => this.openTabSelectorModal()
    });
    this.settingTab = new SettingTab(this.app, this);
    this.addSettingTab(this.settingTab);
    this.settingTab.updateStyleSheet();
  }
  onunload() {
    this.settingTab.updateStyleSheet(true);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  openTabSelectorModal() {
    var _a;
    const rootLeafIds = [];
    this.app.workspace.iterateRootLeaves((leaf) => {
      rootLeafIds.push(leaf.id);
    });
    const targetLeaves = [];
    const { id: rootId, type: rootType } = (_a = this.app.workspace.getMostRecentLeaf()) == null ? void 0 : _a.getRoot();
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (rootId !== leaf.getRoot().id) {
        return;
      }
      if (rootLeafIds.includes(leaf.id) || rootType === "floating") {
        targetLeaves.push(leaf);
      }
    });
    new TabSelectorModal(this.app, this.settings, targetLeaves).open();
  }
};
